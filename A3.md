Channel Tracing
----
* Author(s): Noah Eisen (ncteisen@google.com)
* Approver: markdroth, ctiller
* Status: Draft
* Implemented in: N/A
* Last updated: 01/25/17
* Discussion at: https://groups.google.com/forum/#!topic/grpc-io/WFDj3KeHYTI

## Abstract

The document proposes adding a method to the gRPC C-core Api called grpc_channel_get_trace() which returns a detailed trace for the channel in the form of a JSON string. Eventually this trace could be hooked up to a server with a clean UI, and will be instrumental in debugging channel related bugs.

## Background

Channel connectivity issues are the root cause of a significant portion of user reported gRPC bugs (for example, [here](https://groups.google.com/a/google.com/forum/?utm_medium=email&utm_source=footer#!msg/grpc-users/gPFYbRAex1A/VM7h5FWAAgAJ) and [here](https://groups.google.com/a/google.com/forum/#!topic/grpc-users/0bsOqrxYvRc)). At the moment, gRPC has an extensive logging/tracing system in place. However, when juggling hundreds or thousands of connections, the logs can grow too huge to be quickly useful when debugging channel connectivity issues. Often times it is difficult to determine what events led to changes in connectivity.

## Proposal

To implement channel tracing, we will introduce a dedicated, in-memory tracing object that is owned by each channel and subchannel. The object will record trace for all interesting things that happen to a channel, like address resolution, subchannel creation, channel state changes, etc etc.

We will add a new function to the grpc channel api that allows library users to retrieve all of the trace for the channel as a JSON object. This returned trace could eventually be hooked into a UI, to allow channel debugging to occur from some external service.

## Rationale

This approach makes it easy to add trace, since each tracer is attached to its respective channel or subchannel. The tracer will also be passed down into the resolver and load balancer to record trace for interesting events that happen there. 

One downside to this approach is the potential for the tracer to bloat memory. For this reason, the logs will be held in circular buffers that cannot grow in size. At a certain point, old trace will be overwritten.

## Implementation

### Basic Design

The implementation will be done in the C-core first. The tracer object will hold a linked list of trace node and a linked list of subchannel tracers. Each of the subchannel tracers will hold their own linked lists of trace nodes.

```
struct grpc_trace_node {
  char* data;
  grpc_error* error;
  gpr_timespec time;
  grpc_connectivity_state connectivity_state;
  grpc_trace_node* next;
};

struct grpc_channel_tracer {
  gpr_mu tracer_mu;
  grpc_trace_node* head_trace;
  grpc_trace_node* tail_trace; 
  grpc_subchannel_tracer* head_subchannel;
  grpc_subchannel_tracer* tail_subchannel;
};

struct grpc_subchannel_tracer {
  gpr_mu tracer_mu;
  grpc_trace_node* head_trace;
  grpc_trace_node* tail_trace; 
  grpc_subchannel_tracer* next;
};
```
### Tracer Functions

The tracer files with expose several calls which with the C-core code can interact with tracers:

```
/* Initializes the tracing object with gpr_malloc. The caller has
   ownership over the returned tracing object */
grpc_channel_tracer* grpc_channel_tracer_init_tracer();
grpc_subchannel_tracer* grpc_subchannel_tracer_init_tracer();

/* Adds a new trace node to the tracing object */
void grpc_channel_tracer_add_trace(grpc_channel_tracer* tracer, 
    char* trace, struct grpc_error* error, gpr_timespec time, 
    grpc_connectivity_state connectivity_state);

/* Adds a subchannel to the tracing object */
void grpc_channel_tracer_add_subchannel(grpc_channel_tracer* tracer, 
    grpc_subchannel_tracer* subchannel);

/* Frees all of the resources held by the tracer object */
void grpc_channel_tracer_destroy_tracer();
```
### API Changes

And finally, the tracer will add a new method to the C-core API:
```
/* returns the tracing data in the form of a grpc json object */
grpc_json* grpc_channel_tracer_get_trace(grpc_channel_tracer* tracer);
```
### Garbage Collection

In order to ensure that the tracer(s) do not use too much memory, both trace nodes and subchannel tracers will be discarded after a time. All trace nodes will be stored in circular buffers, the size of which can be set by toggling the channel tracer channel arg.

At certain points a particular subchannel might stop being used. In order to efficiently discard old subchannels, we will use the following method: when the trace signaling the subchannel's death is about to be overwritten in the parent channel (overwritten because of the circular buffer), we will then discard and free the tracer for that subchannel.
